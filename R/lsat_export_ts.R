#' Export Surface Reflectance Time-Series from the Landsat record using rgee
#'
#' This function exports the surface reflectance time series for a set of point-coordinates
#' from the whole Landsat record using the Google Earth Engine (account required).
#' These resulting time-series can then be processed using the remainder of the lsatTS package workflow.
#' For polygon geometries consider using lsat_get_pixel_centers() to generate pixel center coordinates
#' for all pixels within a given polygon.
#'
#' Please note: Unlike the other functions in this package, this function does NOT
#' return the time-series as an object, instead it returns a list of the tasks issued
#' for the export. The time-series are exported as CSV objects to he GEE user's google drive.
#' This export allows for more efficient scheduling, larger exports and does not require the R session to
#' continue to run in the background while the requests are processed on the Earth Engine.
#'
#' @param pixel_coords_sf Simple feature object of pixel / site coordinates.
#' @param site_from The column name in pixel_coords_sf that specifies the site (defaults to "site" as generated by lsat_get_pixel_centres)
#' @param chunks_from Column name in pixel_coords_sf to divide the exports into chunks. Over-rides chuncking by size (see max_chunk_size).
#' @param this_chunk_only Name of a specific chunk to be exported. Useful for re-exporting a single chunk should the export fail for some reason.
#' @param max_chunk_size Maximum number of pixel / site coordinates to be exported in each chunk. Defaults to 250.
#' @param drive_export_dir Folder on Google Drive to export to. Defaults to "lsatTS_export",
#' @param file_prefix Optional file_prefix.
#' @param startJulian Optional first day of year to extract for.
#' @param endJulian Optional Last day of year to extract for.
#' @param start_date Optional extraction start date.
#' @param end_date Optional extraction end date.
#' @param BUFFER_DIST Buffer distance around pixel / site coordinate (default: 0).
#' @param SCALE Scale for extraction (defaults to 30 m nominal Landsat pixel size)
#' @param MASK_VALUE Optional masking value for global surface water mask (ask Logan for more)
#'
#' @return list of started rgee tasks.
#'
#' @author Jakob J. Assmann and Richard Massey
#' @export lsat_export_ts
#'
#' @examples
#' # Using sf, dplyr and rgee
#' library(sf)
#' library(dplyr)
#' library(rgee)
#'
#' # Initialize EE
#' ee_Initialize()
#'
#' # Generate test points
#' test_points_sf <- st_sfc(st_point(c(-149.6026, 68.62574)),
#'                          st_point(c(-149.6003, 68.62524)),
#'                          st_point(c(-75.78057, 78.87038)),
#'                          st_point(c(-75.77098, 78.87256)),
#'                          st_point(c(-20.56182, 74.47670)),
#'                          st_point(c(-20.55376, 74.47749)), crs = 4326) %>%
#'   st_sf() %>%
#'   mutate(site = c("toolik_1",
#'                       "toolik_2",
#'                       "ellesmere_1",
#'                       "ellesmere_1",
#'                       "zackenberg_1",
#'                       "zackenberg_2"),
#'          region = c("toolik", "toolik",
#'                     "ellesmere", "ellesmere",
#'                     "zackenberg", "zackenberg"))
#' # Export time-series using lsat_export_ts()
#' task_list <- lsat_export_ts(test_points_sf)
#'
#' # Export time-series using with a chunk size of 2
#' task_list <- lsat_export_ts(test_points_sf, max_chunk_size = 2)
#'
#' # Export time-series in chunks by column
#' task_list <- lsat_export_ts(test_points_sf, chunks_from = "region")

lsat_export_ts <- function(pixel_coords_sf,
                             site_from = "site",
                             chunks_from = NULL,
                             this_chunk_only = NULL,
                             max_chunk_size = 250,
                             drive_export_dir = "lsatTS_export",
                             file_prefix = "lsatTS_export",
                             startJulian = 152,
                             endJulian = 243,
                             start_date = "1984-01-01",
                             end_date = "2021-01-01",
                             BUFFER_DIST = 0,
                             SCALE = 30,
                             MASK_VALUE = 0
                             ){

  # confirm rgee is initialized
  tryCatch(rgee::ee_user_info(quiet = T), error = function(e) stop("rgee not initialized!\nPlease intialize rgee. See: https://r-spatial.github.io/rgee/index.html"))

  # Prep Landsat Time series
  bands <- list("SR_B1", "SR_B2", "SR_B3", "SR_B4", "SR_B5", "SR_B6", "SR_B7", "QA_PIXEL", "QA_RADSAT")
  BAND_LIST <- rgee::ee$List(bands)

  # addon assets and bands
  ADDON <- rgee::ee$Image('JRC/GSW1_0/GlobalSurfaceWater')$float()$unmask(MASK_VALUE)
  ADDON_BANDLIST <- rgee::ee$List(list("max_extent"));

  # Blank image for "SR_B6" to replace in collections earlier than LS8
  ZERO_IMAGE <- rgee::ee$Image(0)$select(list("constant"), list("SR_B6"))$selfMask()

  # Set image properties to export
  PROPERTIES <- list("CLOUD_COVER",
                     "COLLECTION_NUMBER",
                     "DATE_ACQUIRED",
                     "GEOMETRIC_RMSE_MODEL",
                     "LANDSAT_PRODUCT_ID",
                     'LANDSAT_SCENE_ID',
                     "PROCESSING_LEVEL",
                     'QA_PIXEL',
                     "QA_RADSAT",
                     "SPACECRAFT_ID",
                     "SUN_ELEVATION")

  # Landsat Surface Reflectance collections
  ls5_1 <- rgee::ee$ImageCollection("LANDSAT/LT05/C02/T1_L2")
  ls5_2 <- rgee::ee$ImageCollection("LANDSAT/LT05/C02/T2_L2")
  ls7_1 <- rgee::ee$ImageCollection("LANDSAT/LE07/C02/T1_L2")
  ls7_2 <- rgee::ee$ImageCollection("LANDSAT/LE07/C02/T2_L2")
  ls8_1 <- rgee::ee$ImageCollection("LANDSAT/LC08/C02/T1_L2")
  ls8_2 <- rgee::ee$ImageCollection("LANDSAT/LC08/C02/T2_L2")

  ALL_BANDS <- BAND_LIST$cat(ADDON_BANDLIST)

  # merge all collections into one
  LS_COLL <- ls5_1$
    merge(ls7_1$
         merge(ls8_1$
                merge(ls5_2$
                       merge(ls7_2$
                              merge(ls8_2)))))$
    filterDate(start_date, end_date)$
    filter(rgee::ee$Filter$calendarRange(startJulian, endJulian, "day_of_year"))$
    #.filterBounds(table)
    map(function(image){
      image = ee$Algorithms$If(image$bandNames()$size()$
                                 eq(ee$Number(10)),
                               image,
                               image$addBands(ZERO_IMAGE))
      return(image)})$
    map(function(image) {return(image$addBands(ADDON, ADDON_BANDLIST))})$
    select(ALL_BANDS)$
    map(function(image){ return(image$float())} )


  # Check if chunks_from was specified, if not determine chunks
  if(!is.null(chunks_from)){
    if(!(chunks_from %in% colnames(pixel_coords_sf))) stop("Invalid colum name specified for chunks_from")
  } else {
    n_chunks <- floor(nrow(pixel_coords_sf) / max_chunk_size) + 1
    pixel_coords_sf$chunk_id <- paste0("chunk_", sort(rep(1:n_chunks, max_chunk_size)))[1:nrow(pixel_coords_sf)]
    chunks_from <- "chunk_id"
  }

  # Check if this_chunk_only was specified if so remove all other chunks
  if(!is.null(this_chunk_only)){
    pixel_coords_sf <- pixel_coords_sf[sf::st_drop_geometry(pixel_coords_sf)[, chunks_from] == this_chunk_only,]
  }

  # Status:
  cat(paste0("Exporting time-series for ", nrow(pixel_coords_sf), " pixels",
             " in ", length(unique(sf::st_drop_geometry(pixel_coords_sf)[,chunks_from])), " chunks.\n"))

  # Retrieve time-series by chunk
  task_list <- pixel_coords_sf %>% split(., sf::st_drop_geometry(.)[,chunks_from]) %>%
    purrr::map(function(chunk){
      # Status
      cat(paste0("Submitting task to EE for chunk_id: ", sf::st_drop_geometry(chunk)[,chunks_from][1], ".\n"))
      # Upload chunk to sf to reduce size keep only necessary columns
      ee_chunk <- rgee::sf_as_ee(chunk[,c("geometry", site_from, chunks_from)])
      # Retrieve Landsat time-series
      ee_chunk_export <- ee_chunk$map(function(feature){
          return(
            # Create FC containing a single empty image
            # This will ensure all bands are present in the export
            rgee::ee$ImageCollection$fromImages(
            list(rgee::ee$Image(list(0,0,0,0,0,0,0,0,0,0))$
                   select(list(0,1,2,3,4,5,6,7,8,9), ALL_BANDS)$
                   copyProperties(ls8_1$first())))$
              # Merge with extraction of time-series form whole Landsat collection
              merge(LS_COLL$filterBounds(feature$geometry()))$
                # For each image in the collection ....
                map(function(image){
                  # Create a feature
                return(rgee::ee$Feature(feature$geometry(),
                                  # fill it with the point value extracted with
                                  # reduceRegion and the first() reducer at the set SCALE
                                  image$reduceRegion(rgee::ee$Reducer$first(),
                                                     feature$geometry(),
                                                     SCALE))$
                         # copy the image properties to the feature (incl. date and image metadata)
                         copyProperties(image, PROPERTIES)$
                         # assign a pixel and chunk id columns for identification
                         set(site_from, feature$get(site_from))$
                         set(chunks_from, feature$get(chunks_from)))
              }))
        })$flatten()
      # Prepare export task
      chunk_task <- rgee::ee_table_to_drive(
        collection = ee_chunk_export,
        description = paste0("lsatTS_export_", sf::st_drop_geometry(chunk)[,chunks_from][1]),
        folder = drive_export_dir,
        fileNamePrefix = paste0(file_prefix, "_", sf::st_drop_geometry(chunk)[,chunks_from][1]),
        timePrefix = F,
        fileFormat = "csv")
      # Submit export task
      chunk_task$start()

      # Return nothing
      return(chunk_task)
    })
  # Status update
  cat(crayon::green("Done!\n"))
  cat("You can monitor the progress of the task(s) using rgee's ee_monitoring() or the GEE WebAPI.\n")
  return(task_list)
}
