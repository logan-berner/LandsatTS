#' Clean Landsat Data
#'
#' @description
#' This function filters out observations that exhibit:
#' (1) clouds and optionally water and snow;
#' (2) imposibly high reflectance (>1.0) and abnormally low reflectance (<0.005);
#' (3) scene cloud cover above a user-defined threshold;
#' (4) geometric uncertainty exceeding a user-defined threshold.
#' More information about Landsat Quality Bands here https://landsat.usgs.gov/collectionqualityband

#' @param dt Data.table generated by calling lsat_general_prep().
#' @param cloud.max Maximum allowable cloud cover in Landsat scene (percentage).
#' @param geom.max Maximum allowable geometric uncertainty (meters).
#' @param sza.max Maximum allowable solar zenith angle (degrees).
#' @param filter.snow (TRUE/FALSE) Remove observations with CFmask flag = snow.
#' @param filter.water (TRUE/FALSE) Remove observations with CFmask flag = water or where innundated based on JRC Global Surface Water Dataset.
#'
#' @return A data.table that includes Landsat observations that met the quality control criteria
#' @import data.table
#' @export lsat_clean_data
#'
#' @examples # lsat.dt <- lsat_clean_dt(lsat.dt, cloud.max=80, geom.max=30, sza.max=60, filter.snow = T, filter.water = T)

lsat_clean_data <- function(dt, cloud.max=80, geom.max=30, sza.max=60, filter.snow = T, filter.water = T){
  dt <- data.table::data.table(dt)
  n.orig <- nrow(dt)

  # pixel flags for clear sky
  dt$clear <- apply(X = data.table(pixel.qa=dt$pixel.qa), MARGIN = 1, FUN = clear_value)
  dt <- dt[clear == 1]

  # pixel flags for snow
  if (filter.snow == T){
    dt$snow <- apply(X = data.table(pixel.qa=dt$pixel.qa), MARGIN = 1, FUN = snow_flag)
    dt <- dt[snow == 0]
  }

  # pixel flags for water and JRC Max Water Extent
  if (filter.water == T){
    dt$water <- apply(X = data.table(pixel.qa=dt$pixel.qa), MARGIN = 1, FUN = water_flag)
    dt <- dt[water == 0]

    dt$jrc.water <- as.numeric(dt$jrc.water)
    dt <- dt[jrc.water == 0]

  }

  # scene flags
  dt <- dt[cloud.cover <= cloud.max & geometric.rmse.model <= geom.max & solar.zenith.angle <= sza.max & radsat.qa == 0]

  # filter out unrealistic band values
  dt <- dt[blue > 0.005][green > 0.005][red > 0.005][nir > 0.005]
  dt <- dt[blue < 1][green < 1][red < 1][nir < 1]

  n.final <- nrow(dt)
  n.removed <- n.orig - n.final
  print(paste0('removed ', n.removed, ' of ', n.orig, ' observations (', round(n.removed / n.orig * 100, 2), '%)'))
  dt
}

# LANDSAT CLEAR SKY BIT VALUES (returns 1 if clear and 0 if not clear)
clear_value = function(x) {
  bit_str = paste(as.integer(intToBits(x)), collapse="") # reverse order of bits, left to right
  # conditions
  fill_val = substr(bit_str, 1, 1) == '1'
  clear = substr(bit_str, 2, 2) == '0'
  cloud_shadow = substr(bit_str, 4, 4) == '1'
  cloud = substr(bit_str, 6, 6) == '1'
  cloud_conf = substr(bit_str, 7, 8) == '11' | substr(bit_str, 7, 8) == '01'
  cirrus_conf = substr(bit_str, 9, 10) == '11' | substr(bit_str, 9, 10) == '01'
  terrain_occ = substr(bit_str, 11, 11) == '1'

  if(fill_val | cloud_shadow | cloud | cloud_conf | cirrus_conf | terrain_occ){
    return(0)
  }  else{
    return(1)
  }
}

# filter snow
snow_flag = function(x) {
  # reverse order of bits, left to right
  bit_str = paste(as.integer(intToBits(x)), collapse="")
  snow = substr(bit_str, 5, 5) == '1'
  if(snow){return(1)}  else{return(0)}
}

# filter water
water_flag = function(x) {
  # reverse order of bits, left to right
  bit_str = paste(as.integer(intToBits(x)), collapse="")
  water = substr(bit_str, 3, 3) == '1'
  if(water){return(1)}  else{return(0)}
}

